/**
 * Export service for generating various formats from podcast analysis
 */

/**
 * Generate Markdown export (Obsidian/Notion compatible)
 * @param {Object} data - Complete podcast data
 * @returns {string} - Markdown formatted content
 */
export function exportToMarkdown(data) {
  const { analysis, metadata, chapters, speakerStats, sentimentStats, processingTime, timestamp } = data;

  let markdown = '';

  // Header with metadata
  markdown += `# ${analysis.title}\n\n`;

  if (metadata?.platform) {
    markdown += `**Platform:** ${metadata.platform.icon} ${metadata.platform.name}\n`;
  }

  markdown += `**Analyzed:** ${new Date(timestamp).toLocaleDateString()}\n`;
  markdown += `**Processing Time:** ${processingTime}\n\n`;

  // Summary
  markdown += `## Summary\n\n`;
  markdown += `${analysis.summary}\n\n`;

  // Tags
  if (analysis.tags && analysis.tags.length > 0) {
    markdown += `**Tags:** ${analysis.tags.map(tag => `#${tag.replace(/\s+/g, '-')}`).join(' ')}\n\n`;
  }

  // Speakers
  if (speakerStats && speakerStats.length > 0) {
    markdown += `## Speakers\n\n`;
    speakerStats.forEach(speaker => {
      const minutes = Math.floor(speaker.totalTime / 60000);
      markdown += `- **Speaker ${speaker.speaker}:** ${minutes}m speaking time, ${speaker.utteranceCount} segments\n`;
    });
    markdown += '\n';
  }

  // Sentiment
  if (sentimentStats) {
    const total = sentimentStats.positive + sentimentStats.negative + sentimentStats.neutral;
    if (total > 0) {
      markdown += `## Sentiment Analysis\n\n`;
      markdown += `- ðŸ˜Š Positive: ${((sentimentStats.positive / total) * 100).toFixed(1)}%\n`;
      markdown += `- ðŸ˜ Neutral: ${((sentimentStats.neutral / total) * 100).toFixed(1)}%\n`;
      markdown += `- ðŸ˜Ÿ Negative: ${((sentimentStats.negative / total) * 100).toFixed(1)}%\n\n`;
    }
  }

  // Chapters
  if (chapters && chapters.length > 0) {
    markdown += `## Chapters\n\n`;
    chapters.forEach((chapter, index) => {
      const startMin = Math.floor(chapter.start / 60000);
      const startSec = Math.floor((chapter.start % 60000) / 1000);
      markdown += `### ${index + 1}. ${chapter.headline}\n\n`;
      markdown += `**Time:** ${startMin}:${String(startSec).padStart(2, '0')}\n\n`;
      markdown += `${chapter.summary}\n\n`;
    });
  }

  // Highlights
  if (analysis.highlights && analysis.highlights.length > 0) {
    markdown += `## Key Highlights\n\n`;
    analysis.highlights.forEach((highlight, index) => {
      const text = typeof highlight === 'string' ? highlight : highlight.text;
      const timestamp = typeof highlight === 'object' && highlight.timestamp ? highlight.timestamp : null;
      const speaker = typeof highlight === 'object' && highlight.speaker ? highlight.speaker : null;

      markdown += `${index + 1}. ${text}`;
      if (timestamp) markdown += ` [${timestamp}]`;
      if (speaker) markdown += ` _(Speaker ${speaker})_`;
      markdown += '\n';
    });
    markdown += '\n';
  }

  // Key Takeaways
  if (analysis.keyTakeaways && analysis.keyTakeaways.length > 0) {
    markdown += `## Key Takeaways\n\n`;
    analysis.keyTakeaways.forEach((takeaway, index) => {
      markdown += `${index + 1}. ${takeaway}\n`;
    });
    markdown += '\n';
  }

  // Related Topics
  if (analysis.similarTopics && analysis.similarTopics.length > 0) {
    markdown += `## Related Topics\n\n`;
    analysis.similarTopics.forEach(topic => {
      markdown += `- **[[${topic.topic}]]**: ${topic.description}\n`;
    });
    markdown += '\n';
  }

  // Follow-up Questions
  if (analysis.followUps && analysis.followUps.length > 0) {
    markdown += `## Follow-up Questions\n\n`;
    analysis.followUps.forEach((question, index) => {
      markdown += `${index + 1}. ${question}\n`;
    });
    markdown += '\n';
  }

  // Footer
  markdown += `---\n\n`;
  markdown += `*Generated by Podcast Summarizer*\n`;

  return markdown;
}

/**
 * Generate JSON export
 * @param {Object} data - Complete podcast data
 * @returns {string} - JSON formatted content
 */
export function exportToJSON(data) {
  return JSON.stringify(data, null, 2);
}

/**
 * Generate plain text show notes
 * @param {Object} data - Complete podcast data
 * @returns {string} - Plain text formatted content
 */
export function exportToShowNotes(data) {
  const { analysis, metadata, chapters } = data;

  let notes = '';

  // Title and Summary
  notes += `${analysis.title}\n`;
  notes += `${'='.repeat(analysis.title.length)}\n\n`;
  notes += `${analysis.summary}\n\n`;

  // Chapters with timestamps
  if (chapters && chapters.length > 0) {
    notes += `CHAPTERS:\n\n`;
    chapters.forEach(chapter => {
      const startMin = Math.floor(chapter.start / 60000);
      const startSec = Math.floor((chapter.start % 60000) / 1000);
      notes += `${String(startMin).padStart(2, '0')}:${String(startSec).padStart(2, '0')} - ${chapter.headline}\n`;
    });
    notes += '\n';
  }

  // Key Points
  if (analysis.keyTakeaways && analysis.keyTakeaways.length > 0) {
    notes += `KEY POINTS:\n\n`;
    analysis.keyTakeaways.forEach(takeaway => {
      notes += `â€¢ ${takeaway}\n`;
    });
    notes += '\n';
  }

  // Links/Topics
  if (analysis.similarTopics && analysis.similarTopics.length > 0) {
    notes += `RELATED TOPICS:\n\n`;
    analysis.similarTopics.forEach(topic => {
      notes += `â€¢ ${topic.topic}\n`;
    });
  }

  return notes;
}

/**
 * Generate Notion-friendly markdown
 * @param {Object} data - Complete podcast data
 * @returns {string} - Notion formatted markdown
 */
export function exportToNotion(data) {
  const { analysis, chapters, speakerStats } = data;

  let notion = '';

  // Title as H1
  notion += `# ${analysis.title}\n\n`;

  // Summary in callout
  notion += `> ðŸ’¡ ${analysis.summary}\n\n`;

  // Database properties format
  if (analysis.tags && analysis.tags.length > 0) {
    notion += `**Tags:** ${analysis.tags.join(', ')}\n\n`;
  }

  // Toggle for speakers
  if (speakerStats && speakerStats.length > 0) {
    notion += `## ðŸ‘¥ Speakers\n\n`;
    speakerStats.forEach(speaker => {
      const minutes = Math.floor(speaker.totalTime / 60000);
      notion += `- Speaker ${speaker.speaker}: ${minutes} minutes\n`;
    });
    notion += '\n';
  }

  // Table of contents for chapters
  if (chapters && chapters.length > 0) {
    notion += `## ðŸ“š Table of Contents\n\n`;
    chapters.forEach((chapter, index) => {
      notion += `${index + 1}. [${chapter.headline}](#${chapter.headline.toLowerCase().replace(/\s+/g, '-')})\n`;
    });
    notion += '\n';
  }

  // Highlights as numbered list
  if (analysis.highlights && analysis.highlights.length > 0) {
    notion += `## â­ Highlights\n\n`;
    analysis.highlights.forEach((highlight, index) => {
      const text = typeof highlight === 'string' ? highlight : highlight.text;
      notion += `${index + 1}. ${text}\n`;
    });
    notion += '\n';
  }

  // Takeaways as checklist
  if (analysis.keyTakeaways && analysis.keyTakeaways.length > 0) {
    notion += `## âœ… Key Takeaways\n\n`;
    analysis.keyTakeaways.forEach(takeaway => {
      notion += `- [ ] ${takeaway}\n`;
    });
    notion += '\n';
  }

  return notion;
}

/**
 * Download file with given content
 * @param {string} content - File content
 * @param {string} filename - File name
 * @param {string} mimeType - MIME type
 */
export function downloadFile(content, filename, mimeType = 'text/plain') {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copy content to clipboard
 * @param {string} content - Content to copy
 * @returns {Promise<boolean>} - Success status
 */
export async function copyToClipboard(content) {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch (error) {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = content;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand('copy');
      document.body.removeChild(textArea);
      return true;
    } catch (err) {
      document.body.removeChild(textArea);
      return false;
    }
  }
}
